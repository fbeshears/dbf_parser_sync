// Generated by CoffeeScript 1.6.3
(function() {
  var DbfParserSync, Header, convertBinaryToInteger, fs, getFieldType, makeJson, parseDate, parseField, parseFieldSubRecord, parseRecord, path;

  fs = require('fs');

  path = require('path');

  DbfParserSync = (function() {
    function DbfParserSync(dbf_file_name) {
      var buffer, loc, record, sequenceNumber;
      this.dbf_file_name = dbf_file_name;
      buffer = fs.readFileSync(this.dbf_file_name);
      this.header = new Header(buffer, this.get_name());
      sequenceNumber = 0;
      this.records = [];
      loc = this.header.start;
      while (loc < (this.header.start + this.header.numberOfRecords * this.header.recordLength) && loc < buffer.length) {
        record = parseRecord(++sequenceNumber, buffer.slice(loc, loc += this.header.recordLength), this.header);
        this.records.push(record);
      }
      return null;
    }

    DbfParserSync.prototype.get_name = function() {
      var fn;
      fn = this.dbf_file_name.toLowerCase();
      return path.basename(fn, ".dbf");
    };

    DbfParserSync.prototype.get_json = function() {
      var json, obj;
      obj = {
        header: this.header,
        records: this.records
      };
      json = JSON.stringify(obj, void 0, 2);
      return json;
    };

    DbfParserSync.prototype.get_header = function() {
      return this.header;
    };

    DbfParserSync.prototype.get_records = function() {
      return this.records;
    };

    DbfParserSync.prototype.write_json = function(json_file_name) {
      var e;
      try {
        return fs.writeFileSync(json_file_name, this.get_json());
      } catch (_error) {
        e = _error;
        console.log("Error writing: " + json_file_name);
        throw e;
      }
    };

    return DbfParserSync;

  })();

  parseRecord = function(sequenceNumber, buffer, header) {
    var field, loc, record, v, _i, _len, _ref;
    record = {
      '@sequenceNumber': sequenceNumber,
      '@deleted': (buffer.slice(0, 1))[0] !== 32
    };
    loc = 1;
    _ref = header.fields;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      field = _ref[_i];
      v = parseField(field, buffer.slice(loc, loc += field.length));
      if (v !== '') {
        record[field.name] = v;
      }
    }
    return record;
  };

  parseField = function(field, buffer) {
    var value;
    value = (buffer.toString('utf-8')).replace(/^\x20+|\x20+$/g, '');
    if (field.type === 'Number') {
      value = value === '' || value === '-99999999.99' || value === '-99999999.990' ? '' : value;
      value = value.toString();
    } else {
      value = value.toString();
    }
    return value;
  };

  Header = (function() {
    function Header(buffer, name) {
      var f, i, _i, _ref;
      this.name = name;
      this.type = (buffer.slice(0, 1)).toString('utf-8');
      this.dateUpdated = parseDate(buffer.slice(1, 4));
      this.numberOfRecords = convertBinaryToInteger(buffer.slice(4, 8));
      this.start = convertBinaryToInteger(buffer.slice(8, 10));
      this.recordLength = convertBinaryToInteger(buffer.slice(10, 12));
      this.fields = [];
      for (i = _i = 32, _ref = this.start - 32; _i <= _ref; i = _i += 32) {
        f = parseFieldSubRecord(buffer.slice(i, i + 32));
        if (f.name !== '' && f.name !== '\r') {
          this.fields.push(f);
        }
      }
      return null;
    }

    return Header;

  })();

  parseDate = function(buffer) {
    var day, month, start_year, two_digit_year, year;
    two_digit_year = convertBinaryToInteger(buffer.slice(0, 1));
    start_year = two_digit_year >= 50 ? 1900 : 2000;
    year = start_year + two_digit_year;
    month = (convertBinaryToInteger(buffer.slice(1, 2))) - 1;
    day = convertBinaryToInteger(buffer.slice(2, 3));
    return (new Date(year, month, day)).toISOString().slice(0, 10);
  };

  parseFieldSubRecord = function(buffer) {
    var header;
    return header = {
      name: ((buffer.slice(0, 11)).toString('utf-8')).replace(/[\u0000]+$/, '').toLowerCase(),
      type: getFieldType((buffer.slice(11, 12)).toString('utf-8')),
      displacement: convertBinaryToInteger(buffer.slice(12, 16)),
      length: convertBinaryToInteger(buffer.slice(16, 17)),
      decimalPlaces: convertBinaryToInteger(buffer.slice(17, 18))
    };
  };

  convertBinaryToInteger = function(buffer) {
    return buffer.readInt32LE(0, true);
  };

  getFieldType = function(dbf_type_code) {
    var ft;
    switch (dbf_type_code) {
      case "C":
      case "M":
        ft = "String";
        break;
      case "N":
        ft = "Number";
        break;
      case "L":
        ft = "Boolean";
        break;
      case "D":
        ft = "Date";
        break;
      default:
        ft = "String";
    }
    return ft;
  };

  makeJson = function(dbf_file_name, json_file_name, debug) {
    var e, p;
    if (debug == null) {
      debug = false;
    }
    if (debug) {
      console.log("----------------------------");
      console.log("Parsing dbf file in: " + dbf_file_name);
      console.log("Saving in json file: " + json_file_name);
    }
    try {
      p = new DbfParserSync(dbf_file_name);
    } catch (_error) {
      e = _error;
      console.log("Error parsing: " + dbf_file_name);
      throw e;
    }
    try {
      fs.writeFileSync(json_file_name, p.get_json());
    } catch (_error) {
      e = _error;
      console.log("Error writing: " + json_file_name);
      throw e;
    }
    if (debug) {
      console.log("Finished write to %s", json_file_name);
    }
    return null;
  };

  module.exports = {
    DbfParserSync: DbfParserSync,
    makeJson: makeJson
  };

}).call(this);
